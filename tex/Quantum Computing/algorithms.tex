\begin{topic}{deutsch-jozsa-algorithm}{Deutsch--Jozsa algorithm}
    The \emph{Deutsch--Jozsa algorithm} is a quantum algorithm to solve the following problem:
    
    \textbf{Problem}: Given $x \in \{ 0, 1 \}^N$ for some $N = 2^n$, such that either all $x_i$ are equal (in this case, $x$ is called `constant'), or $N / 2$ of the $x_i$ are $0$ and $N / 2$ are $1$ (in this case, $x$ is called `balanced'). Determine whether $x$ is constant or balanced.
    
    \textbf{Algorithm}: Denote by $\mathcal{O}$ the oracle which acts as $\mathcal{O} \ket{i} = (-1)^{x_i} \ket{i}$ for all $i \in \{ 0, 1 \}^n$.
    \begin{enumerate}[label=(\arabic*)]
        \item Start with the $n$-qubit state $\ket{0^n}$.
        \item Apply a \tref{hadamard-gate}{Hadamard gate} to each qubit to obtain the state
        \[ \frac{1}{\sqrt{2^n}} \sum_{i \in \{ 0, 1 \}^n } \ket{i} . \]
        \item Apply the oracle $\mathcal{O}$ to obtain the state
        \[ \frac{1}{\sqrt{2^n}} \sum_{i \in \{ 0, 1 \}^n} (-1)^{x_i} \ket{i} . \]
        \item Apply a Hadamard gate to each qubit to obtain the state
        \[ \frac{1}{2^n} \sum_{i \in \{ 0, 1 \}^n} (-1)^{x_i} \sum_{j \in \{ 0, 1 \}^n} (-1)^{i \cdot j} \ket{j} . \]
        In particular, the amplitude of the $\ket{0^n}$-state in the final superposition is
        \[ \frac{1}{2^n} \sum_{i \in \{ 0, 1 \}^n} (-1)^{x_i} = \begin{cases}
            1 & \textup{if } x_i = 0 \textup{ for all } i , \\
            -1 & \textup{if } x_i = 1 \textup{ for all } i , \\
            0 & \textup{if } x \textup{ is balanced} .
        \end{cases} \]
        Measuring will yield $\ket{0^n}$ if $x$ is constant, and any other state if $x$ is balanced.
    \end{enumerate}
\end{topic}

\begin{topic}{bernstein-vazirani-algorithm}{Bernstein--Vazirani algorithm}
    The \emph{Bernstein--Vazirani algorithm} is a quantum algorithm to solve the following problem:
    
    \textbf{Problem}: Given $x \in \{ 0, 1 \}^N$ for some $N = 2^n$, such that $x_i = (i \cdot s) \mod 2$ for some unknown $s \in \{ 0, 1 \}^n$. The problem is to determine $s$.

    \textbf{Algorithm}: Denote by $\mathcal{O}$ the oracle which acts as $\mathcal{O} \ket{i} = (-1)^{x_i} \ket{i}$ for all $i \in \{ 0, 1 \}^n$.
    \begin{enumerate}[label=(\arabic*)]
        \item Start with the $n$-qubit state $\ket{0^n}$.
        \item Apply a \tref{hadamard-gate}{Hadamard gate} to each qubit to obtain the state
        \[ \frac{1}{\sqrt{2^n}} \sum_{i \in \{ 0, 1 \}^n } \ket{i} . \]
        \item Apply the oracle $\mathcal{O}$ to obtain the state
        \[ \frac{1}{\sqrt{2^n}} \sum_{i \in \{ 0, 1 \}^n} (-1)^{x_i} \ket{i} = \frac{1}{\sqrt{2^n}} \sum_{i \in \{ 0, 1 \}^n} (-1)^{i \cdot s} \ket{i} . \]
        \item Apply a Hadamard gate to each qubit to obtain the state $\ket{s}$.
        \item Measure the qubits to find $s$.
    \end{enumerate}
\end{topic}

\begin{topic}{simon-algorithm}{Simon's algorithm}
    \emph{Simon's algorithm} is a quantum algorithm to solve the following problem:

    \textbf{Problem}: Given $x = (x_0, \ldots, x_{N - 1})$ for some $N = 2^n$, where $x_i \in \{ 0, 1 \}^n$, with the property that there is some unknown non-zero $s \in \{ 0, 1 \}^n$ such that $x_i = x_j$ if and only if ($i = j$ or $i = j \oplus s$). Determine $s$.

    Note that $x$, viewed as a function from $\{ 0, \ldots, N - 1 \}$ to $\{ 0, \ldots, N - 1 \}$ is a $2$-to-$1$ function, whose $2$-to-$1$-ness is encoded by the unknown \textit{mask} $s$.

    \textbf{Algorithm}: Denote by $\mathcal{O}$ the oracle which acts as $\mathcal{O} \ket{i} \ket{y} = \ket{i} \ket{y \oplus x_i}$ for all $i \in \{ 0, 1 \}^n$.
    \begin{enumerate}[label=(\arabic*)]
        \item Start with the $2n$-qubit state $\ket{0^n} \otimes \ket{0^n}$.
        \item Apply \tref{hadamard-gate}{Hadamard gates} to the first $n$ qubits to obtain the state
        \[ \frac{1}{\sqrt{2^n}} \sum_{i \in \{ 0, 1 \}^n} \ket{i} \otimes \ket{0^n} . \]
        \item Apply the oracle $\mathcal{O}$ to obtain the state
        \[ \frac{1}{\sqrt{2^n}} \sum_{i \in \{ 0, 1 \}^n} \ket{i} \otimes \ket{x_i} . \]
        \item Measure the last $n$ qubits to obtain some value $x_i$. The state will now have collapsed to
        \[ \frac{1}{\sqrt{2}} (\ket{i} + \ket{i \oplus s}) \otimes \ket{x_i} . \]
        \item Apply Hadamard gates to the first $n$ qubits to obtain the state
        \[ \begin{aligned}
            \frac{1}{\sqrt{2^{n + 1}}} \left( \sum_{j \in \{ 0, 1 \}^n} (-1)^{i \cdot j} \ket{j} + \sum_{j \in \{ 0, 1 \}^n} (-1)^{(i \oplus s) \cdot j} \ket{j} \right) \\
            = \frac{1}{\sqrt{2^{n + 1}}} \left( \sum_{j \in \{ 0, 1 \}^n} (-1)^{i \cdot j} (1 + (-1)^{s \cdot j}) \ket{j} \right) .
        \end{aligned} \]
        \item Measure the first $n$ qubits to obtain some value $j \in \{ 0, 1 \}^n$. Since $\ket{j}$ has non-zero amplitude if and only if $s \cdot j \equiv 0 \mod 2$, this measurement yields a random element uniformly distributed from the set $\{ j \in \{ 0, 1 \}^n \mid s \cdot j \equiv 0 \mod 2 \}$. Such an element corresponds to a linear equation that gives information about $s$.
        \item Repeat the above until $n - 1$ linearly independent equations are obtained.
        \item Solve for $s$.
    \end{enumerate}
    Simon's algorithm uses $O(n)$ calls to $\mathcal{O}$, and polynomially in $n$ many operations to solve for $s$.
\end{topic}

\begin{topic}{kitaev-phase-estimation-algorithm}{Kitaev's phase estimation algorithm}
    Given a unitary $U$ and eigenvector $\ket{\psi}$ whose eigenvalue is $\lambda = \exp(2 \pi i \phi)$ for some $\phi \in [0, 1)$, \emph{Kitaev's phase estimation algorithm} is a quantum algorithm to compute $\phi$, given $U$ and $\ket{\psi}$.

    \textbf{Algorithm}: For simplicity, assume that $\phi$ can be expressed with $n$ bits of precision, that is, $\phi = \phi_1 / 2 + \phi_2 / 4 + \ldots + \phi_i / 2^n$.
    \begin{enumerate}[label=(\arabic*)]
        \item Start with the $2n$-qubit state $\ket{0^n} \otimes \ket{\psi}$.
        \item For $N = 2^n$, apply the \tref{quantum-fourier-transform}{quantum Fourier transform} $F_N$ to the first $n$ qubits to obtain the state
        \[ \frac{1}{\sqrt{N}} \sum_{j = 0}^{N - 1} \ket{j} \otimes \ket{\psi} . \]
        (Alternatively, applying the $n$-fold \tref{hadamard-gate}{Hadamard gate} $H^{\otimes n}$ has the same effect.)
        \item Apply the operation $\ket{j} \otimes \ket{\psi} \mapsto \ket{j} \otimes U^j \ket{\psi} = \exp(2 \pi i \phi j) \ket{j} \otimes \ket{\psi}$. This can be implemented, for instance, using controlled $U$ gates. This yields the state
        \[ \frac{1}{\sqrt{N}} \sum_{j = 0}^{N - 1} \exp(2 \pi i \phi j) \ket{j} \otimes \ket{\psi} . \]
        \item Apply the inverse quantum Fourier transform $F_N^{-1}$ to the first $n$ qubits to obtain the state
        \[ \ket{\phi_1 \phi_2 \cdots \phi_n} \otimes \ket{\psi} . \]
        \item Measure first $n$ qubits to obtain $\phi$.
    \end{enumerate}
\end{topic}

% \begin{topic}{shor-algorithm}{Shor's algorithm}
    
% \end{topic}
